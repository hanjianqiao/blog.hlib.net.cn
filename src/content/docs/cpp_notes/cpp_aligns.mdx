---
title: C++对齐规则
description: Get started building your docs site with Starlight.
template: doc
---

### 1 对齐值得基本概念

对齐值指的是一个地址相对于某个数值的倍数关系。在 C++ 中，每个数据类型都有其默认的对齐值，一般来说，这个值就是该类型的大小。比如：

- `char` 的对齐值为1字节
- `short` 的对齐值为2字节
- `int` 的对齐值为4字节
- `float` 的对齐值为4字节
- `double` 的对齐值在32位系统中是4字节，在64位系统中通常是8字节
- 结构体的对齐值是其最大成员的对齐值

### 2 对齐规则的核心要点

#### 2.1 成员对齐
结构体或类的每个成员的起始地址必须是该成员对齐值的整数倍。若前一个成员结束后剩余的空间不足，就需要进行填充。

**示例**：
```cpp
struct S1 {
    char a;    // 1字节，起始地址为0
    int b;     // 4字节，起始地址需为4（填充3字节）
    short c;   // 2字节，起始地址为8
};
// 总大小：1 + 3（填充） + 4 + 2 = 10字节
// 但由于结构体整体对齐的要求，最终大小为12字节
```

#### 2.2 结构体整体对齐
结构体的总大小必须是其最大对齐值的整数倍。如果不满足这一条件，就需要在结构体的末尾进行填充。

**示例**：
```cpp
struct S2 {
    char a;    // 1字节，起始地址为0
    short b;   // 2字节，起始地址为2（填充1字节）
    char c;    // 1字节，起始地址为4
};
// 总大小：1 + 1（填充） + 2 + 1 = 5字节
// 最大对齐值为2，所以最终大小为6字节（填充1字节）
```

#### 2.3 嵌套结构体的对齐
嵌套结构体的对齐值是其自身最大成员的对齐值，而不是嵌套结构体整体的对齐值。

**示例**：
```cpp
struct Inner {
    char a;    // 1字节
    int b;     // 4字节，起始地址为4（填充3字节）
};             // 大小为8字节，对齐值为4

struct Outer {
    short c;   // 2字节，起始地址为0
    Inner d;   // 8字节，起始地址为4（填充2字节）
};
// 总大小：2 + 2（填充） + 8 = 12字节
```

### 3 对齐方式的控制方法

#### 3.1 #pragma pack
借助 `#pragma pack` 指令，能够改变默认的对齐方式。

**示例**：
```cpp
#pragma pack(push, 1)  // 设置1字节对齐
struct Packed {
    char a;    // 1字节
    int b;     // 4字节，起始地址为1
    short c;   // 2字节，起始地址为5
};             // 总大小：1 + 4 + 2 = 7字节
#pragma pack(pop)   // 恢复默认对齐
```

#### 3.2 alignas 说明符（C++11及以后版本）
使用 `alignas` 说明符可以明确指定对齐值。

**示例**：
```cpp
struct alignas(16) AlignedStruct {
    int a;     // 4字节
    double b;  // 8字节
};             // 总大小为16字节，强制按16字节对齐
```

### 4 对齐规则带来的影响
#### 4.1 内存占用
合理安排结构体成员的顺序能够减少填充，从而降低内存占用。

**示例**：
```cpp
// 不良顺序
struct BadOrder {
    char a;    // 1字节
    double b;  // 8字节，起始地址为8（填充7字节）
    int c;     // 4字节，起始地址为16
};             // 总大小：1 + 7（填充） + 8 + 4 = 20字节
               // 整体对齐后为24字节

// 优化顺序
struct GoodOrder {
    double b;  // 8字节
    int c;     // 4字节，起始地址为8
    char a;    // 1字节，起始地址为12
};             // 总大小：8 + 4 + 1 = 13字节
               // 整体对齐后为16字节
```

#### 4.2 性能表现
对齐的数据访问速度更快，因为未对齐的数据可能需要多次内存访问。

#### 4.3 平台差异
不同的平台和编译器对对齐的处理可能有所不同，特别是在处理 `long double`、SIMD 类型等特殊类型时。

### 5 对齐规则的应用场景
- **硬件交互**：与硬件寄存器进行通信时，需要精确控制结构体的布局。
- **网络协议**：解析网络数据包时，要保证数据的对齐与发送端一致。
- **高性能计算**：在处理大量数据时，合理的对齐可以提高缓存利用率。
- **序列化**：为了确保数据在不同平台之间的兼容性，需要进行紧密打包。

### 6 总结
理解C++的对齐规则，有助于你：
- 优化内存使用，避免不必要的填充。
- 确保数据结构在不同平台上的一致性。
- 提高内存访问效率。

建议你在设计结构体时，按照成员大小从大到小的顺序排列成员，并且谨慎使用 `#pragma pack` 和 `alignas`，防止因过度优化而导致代码的可移植性降低。